# 1：synchronized锁

java的每一个对象都可以作为一个锁
- 1：对于普通方法，锁的是当前new出来的这个对象
- 2：对于静态同步方法，锁的是当前类的Class对象
- 3：对于同步代码块，锁的是synchronized括号里配置的对象


# 2：公平锁和非公平锁
传入true是公平锁

传入false是非公平锁

```private final ReentrantLock lock = new ReentrantLock(true);```

```java
//这个是  ReentrantLock 底层的构造方法


/**
      * Creates an instance of {@code ReentrantLock}.
      * This is equivalent to using {@code ReentrantLock(false)}.
      */
    public ReentrantLock() {
           sync = new NonfairSync();
       }
  /**
    * Creates an instance of {@code ReentrantLock} with the
    * given fairness policy.
    *
    * @param fair {@code true} if this lock should use a fair ordering policy
    */
   public ReentrantLock(boolean fair) {
       sync = fair ? new FairSync() : new NonfairSync();
   }
```
- 非公平锁：线程饿死，效率高    
  - 例子：假如发现一个凳子，就直接坐上去
- 公平锁：阳光普照，效率相对较低
  - 例子：加入发现了一个凳子，先问是否有人吗，如果没有，再坐上去，所以效率低



# 3：可重入锁

- ``synchronized（隐式）lock（显式）这两个都是可重入锁``

解释：可重入锁就是  把家里大门的锁打开，房间里面的们就不用开锁了，可以自由进入所有的房间

```java
public static void main(String[] args) {
        Object o = new Object();
        new Thread(()->{
            synchronized (o){
                System.out.println(Thread.currentThread().getName()+"外层");
                synchronized (o){
                    System.out.println(Thread.currentThread().getName()+"中层");
                    synchronized (o){
                        System.out.println(Thread.currentThread().getName()+"内层");
                    }
                }
            }

        },"T1").start();
    }


输出：
T1外层
T1中层
T1内层   
```























































