# 1：synchronized锁

java的每一个对象都可以作为一个锁
- 1：对于普通方法，锁的是当前new出来的这个对象
- 2：对于静态同步方法，锁的是当前类的Class对象
- 3：对于同步代码块，锁的是synchronized括号里配置的对象


# 2：公平锁和非公平锁
传入true是公平锁

传入false是非公平锁

```private final ReentrantLock lock = new ReentrantLock(true);```

```java
//这个是  ReentrantLock 底层的构造方法


/**
      * Creates an instance of {@code ReentrantLock}.
      * This is equivalent to using {@code ReentrantLock(false)}.
      */
    public ReentrantLock() {
           sync = new NonfairSync();
       }
  /**
    * Creates an instance of {@code ReentrantLock} with the
    * given fairness policy.
    *
    * @param fair {@code true} if this lock should use a fair ordering policy
    */
   public ReentrantLock(boolean fair) {
       sync = fair ? new FairSync() : new NonfairSync();
   }
```
- 非公平锁：线程饿死，效率高    
  - 例子：假如发现一个凳子，就直接坐上去
- 公平锁：阳光普照，效率相对较低
  - 例子：加入发现了一个凳子，先问是否有人吗，如果没有，再坐上去，所以效率低



# 3：可重入锁

- ``synchronized（隐式）lock（显式）这两个都是可重入锁``

解释：可重入锁就是  把家里大门的锁打开，房间里面的们就不用开锁了，可以自由进入所有的房间

```java
public static void main(String[] args) {
        Object o = new Object();
        new Thread(()->{
            synchronized (o){
                System.out.println(Thread.currentThread().getName()+"外层");
                synchronized (o){
                    System.out.println(Thread.currentThread().getName()+"中层");
                    synchronized (o){
                        System.out.println(Thread.currentThread().getName()+"内层");
                    }
                }
            }

        },"T1").start();
    }


输出：
T1外层
T1中层
T1内层   
```



# 4：死锁

#### 1：什么是死锁：

**两个或者两个线程在执行过程中，因为在争夺资源中造成一种互相等待的现象，如果没有外力的干涉，他们就没有办法执行下去了**

**![image-20220219084739347](笔记.assets/image-20220219084739347.png)**



#### 2：产生死锁的原因

- **系统资源不足**
- **进程运行推进顺序不合适**
- **资源分配不当**

```java
/**
 * @author Stewart
 * @create 2022/2/19
 * @Description 演示死锁
 */
public class DeadLockDemo {
    static Object a = new Object();
    static Object b = new Object();

    public static void main(String[] args) {
        new Thread(()->{
            synchronized (a){
                System.out.println(Thread.currentThread().getName()+"持有锁a,试图获取锁b");
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (b){
                    System.out.println(Thread.currentThread().getName()+"获取锁b");
                }
            }
        },"AA").start();

        new Thread(()->{
            synchronized (b){
                System.out.println(Thread.currentThread().getName()+"持有锁b,试图获取锁a");
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (a){
                    System.out.println(Thread.currentThread().getName()+"获取锁a");
                }
            }
        },"AA").start();
    }
}
```



#### 3：验证是否是死锁

- jps：能查看当前运行的线程
- jstack：jvm自带的堆栈跟踪工具

![image-20220219090133275](笔记.assets/image-20220219090133275.png)



# 5：线程

## 1：创建线程的多种方式

#### 1：继承Thread类

#### 2：实现Runable接口

```
new Thread(()->{
    
},"T1").start();
```

#### 3：Callable接口



#### 4：线程池的方式



#### 5：Runable接口和Callable接口的区别

##### 1：是否有返回值

- Runable没有返回值
- Callable有返回值

##### 2：是否抛出异常

- Runable没有异常
- Callable有异常

##### 3：实现方法的名称不同

- Runable用的是run方法
- Callable用的是call方法



























